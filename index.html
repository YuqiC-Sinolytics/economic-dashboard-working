<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                   Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    }

  /* Wrapper centers and scales content to 70% width */
#charts-wrapper {
  width: 80%;
  margin: 0 auto;
}

#tooltip {
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
               Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
}
  </style>
</head>
<body>

<div id="charts-wrapper">
  <div id="chart-container" style="width:100%; height:200px;"></div>
  <div id="chart-container-export" style="width:100%; height:200px;"></div>
  <div id="chart-container-import" style="width:100%; height:200px;"></div>
</div>

<div id="tooltip" style="position: absolute; opacity: 0; pointer-events: none; background: rgba(0, 0, 0, 0.8); color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 1000;"></div>

<script>
// ====================== 全局配置 ======================
const height = 180;
const margin = { left: 200, right: 200 };
const pointColor = "#003E7F";
const labelTimes = ["2022", "2023-03", "2023-04"];

// ====================== 同步所有图表中相同时间的点的 hover 状态 ======================
function syncHover(time, isHovering) {
  // 找到所有图表中相同时间的点
  d3.selectAll("circle[data-time]")
    .filter(function() {
      return d3.select(this).attr("data-time") === time;
    })
    .style("opacity", function() {
      const currentTime = d3.select(this).attr("data-time");
      const isLabelTime = labelTimes.includes(currentTime);
      return isHovering ? 1 : (isLabelTime ? 1 : 0);
    });
  
  // 找到所有图表中相同时间的标签
  d3.selectAll("text.timeLabel[data-time]")
    .filter(function() {
      return d3.select(this).attr("data-time") === time;
    })
    .style("opacity", function() {
      const currentTime = d3.select(this).attr("data-time");
      const isLabelTime = labelTimes.includes(currentTime);
      return isHovering ? 1 : (isLabelTime ? 1 : 0);
    });
}

// ====================== 可复用的图表生成函数 ======================
function createChart(containerId, data, label, domainInfo) {
  const container = document.getElementById(containerId);
  const width = container.clientWidth;
  const innerWidth = width - margin.left - margin.right;
  const yCenter = height / 2 + 10;

  // 创建 SVG
  const svg = d3.select(`#${containerId}`)
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  // 百分位 scale：domain 是 0-100
  const x = d3.scaleLinear()
    .domain([0, 100])
    .range([0, innerWidth]);

  // 左侧标签
  svg.append("text")
    .attr("x", margin.left - 20)
    .attr("y", yCenter)
    .attr("text-anchor", "end")
    .attr("dominant-baseline", "middle")
    .style("font-size", "18px")
    .style("font-weight", 600)
    .style("fill", "#0A2342")
    .text(label);

  // 画布 group
  const g = svg.append("g")
    .attr("transform", `translate(${margin.left}, 0)`);

  // 横轴线
  g.append("line")
    .attr("x1", 0)
    .attr("x2", innerWidth)
    .attr("y1", yCenter)
    .attr("y2", yCenter)
    .attr("stroke", "#ABBDC9")
    .attr("stroke-width", 1.2);

  // 刻度（基于百分位：25%, 50%, 75%）
  const tickPercentiles = [25, 50, 75];
  const fmt = d3.format(".1f");
  const ticksGroup = g.append("g");

  ticksGroup.selectAll("g.tick")
    .data(tickPercentiles)
    .enter()
    .append("g")
      .attr("class", "tick")
      .each(function(percentile) {
        const xPos = x(percentile);
        const originalValue = domainInfo?.tickValues?.[percentile] ?? percentile;
        const gTick = d3.select(this);
        gTick.append("line")
          .attr("x1", xPos)
          .attr("x2", xPos)
          .attr("y1", yCenter - 6)
          .attr("y2", yCenter + 6)
          .attr("stroke", "#8796A5")
          .attr("stroke-width", 1);
        gTick.append("text")
          .attr("x", xPos)
          .attr("y", yCenter + 20)
          .attr("text-anchor", "middle")
          .style("font-size", "11px")
          .style("fill", "#546579")
          .text(fmt(originalValue));
      });

  // 数据点（使用百分位位置，但保留原始值用于显示）
  const percentileFn = domainInfo?.percentileFn || (() => 50);
  const fmtValue = d3.format(".1f");
  const tooltip = d3.select("#tooltip");
  
  g.selectAll("circle")
    .data(data)
    .enter()
    .append("circle")
      .attr("data-time", d => d.time)  // 添加时间属性用于跨图表查找
      .attr("cx", d => x(percentileFn(d.value)))
      .attr("cy", yCenter)
      .attr("r", 7)
      .attr("fill", pointColor)
      .attr("stroke", "white")
      .attr("stroke-width", 2)
      .style("cursor", "pointer")
      .style("opacity", d => labelTimes.includes(d.time) ? 1 : 0)
      .on("mouseover", function(e, d) {
        syncHover(d.time, true);  // 同步所有图表中相同时间的点
        // 显示 tooltip
        tooltip
          .style("opacity", 1)
          .html(`${d.time}<br>${fmtValue(d.value)}`)
          .style("left", (e.pageX + 10) + "px")
          .style("top", (e.pageY - 10) + "px");
      })
      .on("mousemove", function(e, d) {
        // 更新 tooltip 位置
        tooltip
          .style("left", (e.pageX + 10) + "px")
          .style("top", (e.pageY - 10) + "px");
      })
      .on("mouseout", function(e, d) {
        syncHover(d.time, false);  // 恢复所有图表中相同时间的点
        // 隐藏 tooltip
        tooltip.style("opacity", 0);
      });

  // 时间标签（只显示时间，位置使用百分位）
  g.selectAll("text.timeLabel")
    .data(data)
    .enter()
    .append("text")
      .attr("class", "timeLabel")
      .attr("data-time", d => d.time)  // 添加时间属性用于跨图表查找
      .attr("x", d => x(percentileFn(d.value)))
      .attr("y", yCenter - 15)
      .attr("text-anchor", "middle")
      .style("font-size", "12px")
      .style("fill", "#003E7F")
      .style("opacity", d => labelTimes.includes(d.time) ? 1 : 0)
      .style("cursor", "pointer")
      .text(d => d.time)
      .on("mouseover", function(e, d) {
        syncHover(d.time, true);
        // 显示 tooltip
        tooltip
          .style("opacity", 1)
          .html(`${d.time}<br>${fmtValue(d.value)}`)
          .style("left", (e.pageX + 10) + "px")
          .style("top", (e.pageY - 10) + "px");
      })
      .on("mousemove", function(e, d) {
        // 更新 tooltip 位置
        tooltip
          .style("left", (e.pageX + 10) + "px")
          .style("top", (e.pageY - 10) + "px");
      })
      .on("mouseout", function(e, d) {
        syncHover(d.time, false);
        // 隐藏 tooltip
        tooltip.style("opacity", 0);
      });
}

// ====================== 生成所有图表 ======================
// 解析字符串中的逗号小数
function parseValue(str) {
  if (!str) return null;
  const num = parseFloat(String(str).replace(",", "."));
  return Number.isFinite(num) ? num : null;
}

// 构造 2022 平均 + 最近两个月数据
function buildSeries(data, field) {
  const lastMonths = ["2023-03", "2023-04"];
  const avg2022 = d3.mean(
    data
      .filter(d => d.time.startsWith("2022-"))
      .map(d => d[field])
      .filter(Number.isFinite)
  );

  const series = [];
  if (Number.isFinite(avg2022)) {
    series.push({ time: "2022", value: avg2022 });
  }
  lastMonths.forEach(t => {
    const hit = data.find(d => d.time === t);
    if (hit && Number.isFinite(hit[field])) {
      series.push({ time: t, value: hit[field] });
    }
  });
  return series;
}

// 读 csv 并渲染
d3.dsv(";", "data.csv", d => ({
  time: d.Time,
  manufacture: parseValue(d.Manufacture),
  export: parseValue(d.Export || d.EXport), // 兼容大小写
  import: parseValue(d.Import),
})).then(data => {
  const scaleStart = "2013-05";
  const scaleEnd = "2023-04";
  const scaleWindow = data.filter(
    d => d.time >= scaleStart && d.time <= scaleEnd
  );

  function quantileDomain(values) {
    const nums = values.filter(Number.isFinite).sort((a, b) => a - b);
    if (!nums.length) return null;
    const q25 = d3.quantileSorted(nums, 0.25);
    const q50 = d3.quantileSorted(nums, 0.5);
    const q75 = d3.quantileSorted(nums, 0.75);
    
    // 创建百分位映射函数：给定一个值，返回它在分布中的百分位（0-100）
    function percentileFn(value) {
      if (!Number.isFinite(value)) return 50;
      
      // 边界情况
      if (value <= nums[0]) return 0;
      if (value >= nums[nums.length - 1]) return 100;
      
      // 找到值所在的位置
      let lowerIdx = 0;
      let upperIdx = nums.length - 1;
      
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] >= value) {
          upperIdx = i;
          lowerIdx = i > 0 ? i - 1 : 0;
          break;
        }
      }
      
      // 如果正好等于某个值
      if (nums[lowerIdx] === value) {
        return (lowerIdx / (nums.length - 1)) * 100;
      }
      if (nums[upperIdx] === value) {
        return (upperIdx / (nums.length - 1)) * 100;
      }
      
      // 线性插值
      const lowerValue = nums[lowerIdx];
      const upperValue = nums[upperIdx];
      const lowerPercentile = (lowerIdx / (nums.length - 1)) * 100;
      const upperPercentile = (upperIdx / (nums.length - 1)) * 100;
      
      if (upperValue === lowerValue) {
        return lowerPercentile;
      }
      
      const t = (value - lowerValue) / (upperValue - lowerValue);
      return lowerPercentile + t * (upperPercentile - lowerPercentile);
    }
    
    return {
      percentileFn: percentileFn,
      tickValues: {
        25: q25,
        50: q50,
        75: q75,
      },
    };
  }

  const domains = {
    manufacture: quantileDomain(scaleWindow.map(d => d.manufacture)),
    export: quantileDomain(scaleWindow.map(d => d.export)),
    import: quantileDomain(scaleWindow.map(d => d.import)),
  };

  const manufacturingData = buildSeries(data, "manufacture");
  const exportData = buildSeries(data, "export");
  const importData = buildSeries(data, "import");

  createChart("chart-container", manufacturingData, "Manufacturing", domains.manufacture);
  createChart("chart-container-export", exportData, "Export", domains.export);
  createChart("chart-container-import", importData, "Import", domains.import);
});

</script>
</body>
</html>
